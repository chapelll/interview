1.HTTP 状态码知道哪些？分别什么意思？

答: 
1** - 继续执行
200 - 请求成功
301 - 资源（网页等）被永久转移到其它URL
404 - 请求的资源（网页等）不存在
408 - 请求时间超时
414 - URL过长
5** - 内部服务器错误
502 - 无效的响应

2.HTTP 缓存有哪几种？

答:  ETag   Expires  Cache-Control
(1)ETag是HTTP1.1中的。首先是客户端向服务器发送请求，服务器返回
资源并带上一个ETag(如果资源发送改变ETag也会改变)。客户端收到
ETag会将它保存起来，下次再请求该资源时就将ETag也一并发送出去。
服务器收到ETag后会与该资源现在的ETag相对比，不一致就返回新的
资源，一致就返回304，让浏览器使用上次的缓存。
注意: ETag是要发起请求的

(2)Expires(日期)
Expires是HTTP1.0中的。当浏览器请求一个资源时，服务器会返回该资源
和一个expires，它是一个过期日期。当浏览器再请求这个资源时会比较
本地时间和过期时间，如果再过期时间内就会使用缓存。
缺点: 用户可以更改本地时间，使得永远都不会过期。

(3)Cache-Control(max-age=600s)
Cache-Control也是限制一定时间内使用缓存，与Expires不同的是
它是一个相对时间，类似于一个倒计时，在600s之内会使用本地缓存，
一旦过了600s就不使用了。这就有效避免了用户更改本地时间带来的
影响。

3.GET 和 POST 的区别

答:
(1)GET用于获取资源，POST用于提交资源。
(2)GET没有POST安全。
(3)GET将参数放在URL中，POST将参数放在消息体中，也可以放在
URL中(因此GET的参数有长度限制而POST基本没有)。
(4)GET的请求不会对后端产生影响(幂等)，POST可能会(不幂等)。

4.Cookie V.S. LocalStorage V.S. SessionStorage V.S. Session

答:
(1) Cookie是服务端下发给客户端的一串字符，客户端向同源服务端
发请求的时候会带上这串字符，服务端收到后就会进行成功的验证。
(相当于一个门票，每次发请求都得带上它才能识别出来,一般有4K)
(2) LocalStorage是浏览器保存在本地的一些数据，它不会自动清除
，需要手动清除，一般有5M~10M。
(3) SessionStorage和LocalStorage相似，但它只保存一次会话中的
数据，数据在刷新页面时不会消失，关闭页面就会消失。一般有5M~10M。
(4) Session是会话的意思。一般客户端会给每个客户端下发一个
Session ID，自己也会保留所有的Session。当客户端发送请求
时会将自己的Session ID放在cookie中发送过来，客户端通过发来的
Session ID去寻找自己存储的Session，找到了就通过验证，找不到就
验证失败。
(5) Token (令牌) 是为了解决服务器保存了所有Session,性能不足问题的。
当用户登录后，服务器会根据用户唯一标识符userId进行加密做成一个
Token并下发给用户。用户收到后会保留在本地，然后每次发请求时都要在cookie
上带上这个Token，服务器接收到后会解密Token来验证是哪一个用户。
服务器本身不会存储任何Token，它只保存加密解密的算法，相比session
像是以时间(加密解密Token的时间)换空间(存储session的空间)。

Cookie存放在用户端，Session存放在服务端。

5. HTTP1 和 HTTP2 的区别?

答:
(1)多路复用: 在一次链接中可以有多个请求/响应，不在像以前那样
每次请求都要开辟一个新链接。
(2)服务端推送: 例如我的网页有一个sytle.css的请求，
在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件
推送给客户端，当客户端再次尝试获取sytle.js时就可以直接
从缓存中获取到，不用再发请求了。

6. 输入一个url发生了什么？
(1)查找该URL是否在缓存中，没在的话就使用DNS将URL解析成IP地址。
(2)浏览器根据IP地址与服务器建立连接，并发送HTTP请求。
(3)服务器收到请求，构建响应，将响应根据当前连接发送回去。
(4)浏览器收到响应，开始渲染页面。
    	    	      渲染页面的步骤: 1.根据HTML建立DOM树
			               2.根据CSS建立CSS DOM树
			               3.将两棵树合并成render树(渲染树)
                                                               4.根据render树进行布局(计算文档流、盒模型在页面上的位置及大小)
					             绘制(画出颜色、边框、阴影等)
					             合成(根据重叠关系进行展示)				









