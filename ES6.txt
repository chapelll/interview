1.块级作用域与let、const
(1)使用var声明的变量和函数没有块级作用域的概念，它们的影响
会超出所在本身语句块之外存在(换言之它们会产生全局影响)。
var声明作用于全局或者函数内，声明在函数内的作用于该函数内，
声明于函数外的作用于全局。
变量提升: 用var声明的变量和函数会提到当前作用域的最前面进行
声明(全局就放在最上方，函数内就放在函数内部最上方)，但不会
赋值。之后代码才会继续执行。这也是先打印a后再var a = 1时会
打印出undefined的原因。
函数提升: 函数有两种声明方式，一种是
函数声明: function declaration() {}
函数表达式: var express = function () {}
函数声明在JS解析时进行提升，因此只要在同一块作用域内，
不管函数声明在哪里定义，该函数都可以进行调用。
函数表达式的值在JS运行时确定，在表达式赋值完成后，
该函数才能调用。(类似于var声明的变量)
同时使用var声明变量和函数，函数的声明高于变量。

(2)let声明的变量会处在块级作用域中，作用域之外的地方无法
对其进行访问，不存在变量提升。先声明后使用。
let可以先进行声明，然后才进行赋值

(3)const和let类似，最大的区别是它声明的是常量，必须在声明的
时候就进行赋值，且之后不能对这个变量进行更改。

2.箭头函数
箭头函数比普通书写的函数更简洁。
箭头函数一般被用在需要使用匿名函数的地方。
箭头函数没有自己的this
(就算用.call()/.apply()/.bind()无法改变箭头函数中this的指向)
箭头函数也没有自己的arguments对象。

3.函数默认参数
我们可以给函数设置默认的参数
如果该参数没有传入且用到了它
就会使用默认值(直接在传递参数时写参数 = 默认值)
function multiply(a, b = 1) {
  return a * b;
}

multiply(5, 2); // 10 (正常情况下)
multiply(5);    // 5  (没有传入b，b变成了默认参数1)

4.剩余参数
当我想传入一个长度不确定的参数时，我可以使用剩余参数
function fn(a, b, ...args) {  
   return args.length;
}
最后一个参数 ...args 含义是我的参数不确定，在函数被调用时
...args 会成为一个数组，数组中的值是传递给该函数的多出来
的实参的值，它是一个真数组(arguments是一个假数组)。

5.展开运算符 ...
... 你能够将字面量对象展开为多个元素。
相当于将一个数组或者字符串之类的东西使用逗号展开，再进行其他
运算。

6.模板字符串 ``
比普通的单引号和双引号更高级的使用反引号的字符串。
(1) 支持多行
(2) 可以使用 ${} 在字符串中间插入表达式

7.对象属性加强
(1) 对象的定义支持简洁的语法 
    let a = 1   let b = 2 
    let x = { a, b }
    ES6允许直接写入变量及函数，作为对象的属性及方法
(2) 对象的属性名可以是表达式 obj = {["baz" + quux() ]: 42}

8.解构赋值
对象和数组逐个对应表达式，或称对象字面量和数组字面量，
提供了一种简单的定义一个特定的数据组的方法。
var a, b;               var o = {p: 42, q: true};
[a, b] = [1, 2];        var {p: foo, q: bar} = o;
console.log(a); // 1    console.log(foo); // 42   
console.log(b); // 2    console.log(bar); // true 
简单理解: 批量操作变量赋值,一个一个进行对应

var {a = 10, b = 5} = {a: 3};
console.log(a); // 3  
console.log(b); // 5  
解析: 给a一个默认值10，b一个默认值5，再给a传入真实的值3
打印时a就等于3，而b因为没有传入真实的值就去找默认值5

9.模块
(1) ES6 的模块自动开启严格模式，不管你有没有在模块头部加上 use strict;。
(2) 模块中可以导入和导出各种类型的变量，如函数，对象，字符串，数字，布尔值，类等。
(3) 每个模块都有自己的上下文，每一个模块内声明的变量都是局部变量，不会污染全局作用域。
(4) 每一个模块只加载一次（是单例的）， 若再去加载同目录下同文件，直接从内存中读取。

import 命令会提升到整个模块的头部，首先执行。
在一个文件或模块中，export、import 可以有多个，export default 仅有一个
export default 中的 default 是对应的导出接口变量。

ES Module把一个文件当作一个模块，每个模块有自己的独立作用域。
那如何把每个模块联系起来呢？核心点就是模块的导入（import）与导出（export）。

个人理解: ES6的模块就是一个块级作用域，导入就相当于把那个
块级作用域拿到这里来，但只能调用它暴露出来的属性方法等






